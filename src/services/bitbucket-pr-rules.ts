import {PullRequest, PullRequestActivity} from '../models/models';
import {
  BitbucketCommentAction,
  BitbucketMergeResultOutcome,
  PullRequestActivityAction,
  PullRequestStatus
} from '../models/enums';

/**
 * Check if user was added as a reviewer
 */
export function ReviewerRule(a: PullRequestActivity, lastDataFetchingTimestamp: number, userId?: number) {
  return a.action === PullRequestActivityAction.Updated
    // check if action occurred after last running time
    && a.createdDate >= lastDataFetchingTimestamp
    // make sure activity wasn't generated by myself
    && a.user.id !== userId
    // get activities where I was added as a reviewer
    && a.addedReviewers?.some(r => r.id === userId);
}

/**
 * Check if pr was merged or declined
 */
export function MergedOrDeclinedRule(a: PullRequestActivity, lastDataFetchingTimestamp: number, userId?: number) {
  return (a.action === PullRequestActivityAction.Merged || a.action === PullRequestActivityAction.Declined)
    // make sure activity wasn't generated by myself
    && a.user.id !== userId
    // check if action occurred after last running time
    && a.createdDate >= lastDataFetchingTimestamp;
}

/**
 * Check for comments and first level replies
 */
export function CommentRule(a: PullRequestActivity, lastDataFetchingTimestamp: number, userId?: number) {
  return a.action === PullRequestActivityAction.Commented
    // check if it's a new comment
    && a.commentAction === BitbucketCommentAction.Added
    // make sure it's not my comment
    && (
      a.comment?.author.id !== userId
      // check for first-level replies, todo: add recursion to go deeper
      || a.comment?.comments?.some(cc =>
        cc.updatedDate >= lastDataFetchingTimestamp
        && cc.author.id !== userId)
    )
    // check if action occurred after last running time
    && a.createdDate >= lastDataFetchingTimestamp;
}

/**
 * pr merge result moved to conflicted state
 */
export function ConflictedRule(before: PullRequest, now: PullRequest) {
  return before.properties.mergeResult?.outcome !== BitbucketMergeResultOutcome.Conflicted
    && now.properties.mergeResult?.outcome === BitbucketMergeResultOutcome.Conflicted;
}

/**
 * pr was approved by at least one reviewer
 */
export function ApprovedRule(before: PullRequest, now: PullRequest) {
  return !before.reviewers.some(r => r.approved) && now.reviewers.some(r => r.approved);
}

/**
 *  pr was approved by at least one reviewer
 */
export function NeedsWorkRule(before: PullRequest, now: PullRequest) {
  return !before.reviewers.some(r => r.status === PullRequestStatus.NeedsWork)
    && now.reviewers.some(r => r.status === PullRequestStatus.NeedsWork);
}
